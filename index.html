<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Universal Media Metadata Cleaner - Images & Videos</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            padding: 40px;
        }

        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 10px;
            font-size: 2.5em;
        }

        .subtitle {
            text-align: center;
            color: #666;
            margin-bottom: 30px;
        }

        .media-type-badge {
            display: inline-block;
            padding: 5px 12px;
            border-radius: 15px;
            font-size: 12px;
            font-weight: 600;
            margin-left: 10px;
        }

        .badge-image {
            background: #3498db;
            color: white;
        }

        .badge-video {
            background: #e74c3c;
            color: white;
        }

        .top-actions {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 30px;
            display: none;
        }

        .top-actions.show {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 15px;
        }

        .top-actions-left {
            color: white;
        }

        .top-actions-left h3 {
            margin-bottom: 5px;
            font-size: 1.3em;
        }

        .top-actions-left p {
            opacity: 0.9;
            font-size: 0.9em;
        }

        .top-actions-right {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .upload-section {
            border: 3px dashed #667eea;
            border-radius: 10px;
            padding: 40px;
            text-align: center;
            background: #f8f9ff;
            margin-bottom: 30px;
            transition: all 0.3s;
            cursor: pointer;
        }

        .upload-section:hover {
            border-color: #764ba2;
            background: #f0f1ff;
        }

        .upload-section.dragover {
            border-color: #764ba2;
            background: #e8e9ff;
            transform: scale(1.02);
        }

        input[type="file"] {
            display: none;
        }

        .upload-buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
            flex-wrap: wrap;
            margin-top: 20px;
        }

        .upload-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 15px 30px;
            border: none;
            border-radius: 50px;
            font-size: 16px;
            cursor: pointer;
            transition: transform 0.2s;
            display: inline-block;
        }

        .upload-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(102, 126, 234, 0.4);
        }

        .upload-btn-secondary {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        }

        .upload-btn-video {
            background: linear-gradient(135deg, #fa709a 0%, #fee140 100%);
        }

        .control-panel {
            background: #f8f9fa;
            padding: 25px;
            border-radius: 10px;
            margin-bottom: 30px;
        }

        .control-tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            border-bottom: 2px solid #dee2e6;
            flex-wrap: wrap;
        }

        .tab-btn {
            padding: 12px 24px;
            border: none;
            background: transparent;
            color: #666;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            border-bottom: 3px solid transparent;
            transition: all 0.3s;
        }

        .tab-btn:hover {
            color: #667eea;
        }

        .tab-btn.active {
            color: #667eea;
            border-bottom-color: #667eea;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .settings-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }

        .input-group {
            margin-bottom: 15px;
        }

        .input-group label {
            display: block;
            margin-bottom: 8px;
            color: #333;
            font-weight: 600;
            font-size: 14px;
        }

        .input-group input,
        .input-group select,
        .input-group textarea {
            width: 100%;
            padding: 12px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 14px;
            transition: border-color 0.3s;
            font-family: inherit;
        }

        .input-group input:focus,
        .input-group select:focus,
        .input-group textarea:focus {
            outline: none;
            border-color: #667eea;
        }

        .input-group textarea {
            resize: vertical;
            min-height: 80px;
        }

        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
        }

        .checkbox-group input[type="checkbox"] {
            width: auto;
            cursor: pointer;
        }

        .checkbox-group label {
            margin-bottom: 0;
            cursor: pointer;
            font-weight: 500;
        }

        .range-group {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .range-group input[type="range"] {
            flex: 1;
        }

        .range-value {
            min-width: 50px;
            font-weight: 600;
            color: #667eea;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: 600;
            white-space: nowrap;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .btn-danger {
            background: #e74c3c;
            color: white;
        }

        .btn-danger:hover {
            background: #c0392b;
            transform: translateY(-2px);
        }

        .btn-success {
            background: #2ecc71;
            color: white;
        }

        .btn-success:hover {
            background: #27ae60;
            transform: translateY(-2px);
        }

        .btn-info {
            background: #3498db;
            color: white;
        }

        .btn-info:hover {
            background: #2980b9;
            transform: translateY(-2px);
        }

        .btn-warning {
            background: #f39c12;
            color: white;
        }

        .btn-warning:hover {
            background: #e67e22;
            transform: translateY(-2px);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none !important;
        }

        .btn-large {
            padding: 15px 40px;
            font-size: 16px;
        }

        .btn-small {
            padding: 6px 12px;
            font-size: 12px;
            flex: 1;
        }

        .bulk-actions {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-top: 20px;
        }

        .stats-bar {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-bottom: 30px;
        }

        .stat-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
        }

        .stat-value {
            font-size: 32px;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .stat-label {
            font-size: 13px;
            opacity: 0.9;
        }

        .media-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(320px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .media-card {
            background: #f8f9fa;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            transition: transform 0.3s;
        }

        .media-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 5px 20px rgba(0,0,0,0.15);
        }

        .media-card-preview {
            width: 100%;
            height: 200px;
            object-fit: cover;
            background: #e9ecef;
        }

        .media-card-preview video {
            width: 100%;
            height: 200px;
            object-fit: cover;
        }

        .media-card-body {
            padding: 15px;
        }

        .media-card-title {
            font-size: 14px;
            font-weight: 600;
            color: #333;
            margin-bottom: 8px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .media-card-info {
            font-size: 12px;
            color: #666;
            margin-bottom: 5px;
        }

        .media-card-status {
            display: inline-block;
            padding: 4px 10px;
            border-radius: 20px;
            font-size: 11px;
            font-weight: 600;
            margin-top: 8px;
        }

        .status-original {
            background: #fff3cd;
            color: #856404;
        }

        .status-cleaned {
            background: #d4edda;
            color: #155724;
        }

        .status-processing {
            background: #d1ecf1;
            color: #0c5460;
        }

        .media-card-actions {
            display: flex;
            gap: 8px;
            margin-top: 10px;
        }

        .metadata-preview {
            background: white;
            padding: 10px;
            border-radius: 5px;
            margin-top: 10px;
            font-size: 11px;
            max-height: 100px;
            overflow-y: auto;
        }

        .metadata-item-small {
            display: flex;
            justify-content: space-between;
            padding: 3px 0;
            border-bottom: 1px solid #eee;
        }

        .metadata-key-small {
            font-weight: 600;
            color: #667eea;
        }

        .metadata-value-small {
            color: #666;
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: #e9ecef;
            border-radius: 10px;
            overflow: hidden;
            margin-top: 10px;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
            transition: width 0.3s;
            border-radius: 10px;
        }

        .processing-indicator {
            display: inline-block;
            margin-left: 10px;
        }

        .alert {
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            display: none;
            animation: slideIn 0.3s ease;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .alert.show {
            display: block;
        }

        .alert-success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .alert-info {
            background: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }

        .alert-warning {
            background: #fff3cd;
            color: #856404;
            border: 1px solid #ffeaa7;
        }

        .hidden {
            display: none;
        }

        .upload-icon {
            font-size: 48px;
            margin-bottom: 15px;
        }

        .empty-state {
            text-align: center;
            padding: 60px 20px;
            color: #999;
        }

        .empty-state-icon {
            font-size: 64px;
            margin-bottom: 20px;
            opacity: 0.5;
        }

        .loading-spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(255,255,255,0.3);
            border-radius: 50%;
            border-top-color: white;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .info-box {
            background: #e8f4fd;
            border-left: 4px solid #2196F3;
            padding: 15px;
            margin-top: 15px;
            border-radius: 5px;
            font-size: 13px;
            color: #0d47a1;
        }

        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.7);
            animation: fadeIn 0.3s;
        }

        .modal.show {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .modal-content {
            background: white;
            padding: 30px;
            border-radius: 15px;
            max-width: 900px;
            max-height: 90vh;
            overflow-y: auto;
            width: 90%;
            animation: slideUp 0.3s;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @keyframes slideUp {
            from { transform: translateY(50px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid #eee;
        }

        .modal-header h2 {
            color: #333;
            margin: 0;
        }

        .close-modal {
            background: none;
            border: none;
            font-size: 30px;
            cursor: pointer;
            color: #999;
            line-height: 1;
        }

        .close-modal:hover {
            color: #333;
        }

        .metadata-display {
            background: white;
            padding: 15px;
            border-radius: 8px;
            max-height: 400px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 13px;
        }

        .metadata-item {
            padding: 8px;
            border-bottom: 1px solid #eee;
            display: grid;
            grid-template-columns: 150px 1fr;
            gap: 10px;
        }

        .metadata-item:last-child {
            border-bottom: none;
        }

        .metadata-key {
            font-weight: bold;
            color: #667eea;
            word-break: break-word;
        }

        .metadata-value {
            color: #333;
            word-break: break-all;
        }

        .video-settings-section {
            background: #fff3cd;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 15px;
            border: 2px solid #ffc107;
        }

        .video-settings-section h4 {
            color: #856404;
            margin-bottom: 10px;
        }

        @media (max-width: 768px) {
            .top-actions.show {
                flex-direction: column;
            }
            
            .top-actions-right {
                width: 100%;
            }
            
            .top-actions-right .btn {
                flex: 1;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>🎬 Universal Media Metadata Cleaner</h1>
        <p class="subtitle">Process images and videos - Auto-detects media type • Complete metadata control</p>

        <div id="alert" class="alert"></div>

        <!-- Top Actions Bar -->
        <div id="topActions" class="top-actions">
            <div class="top-actions-left">
                <h3>📦 <span id="topTotalMedia">0</span> Files Loaded</h3>
                <p>
                    <span id="topImageCount">0</span> images • 
                    <span id="topVideoCount">0</span> videos • 
                    <span id="topCleanedMedia">0</span> processed • 
                    <span id="topTotalSize">0 MB</span> total
                </p>
            </div>
            <div class="top-actions-right">
                <button class="btn btn-danger btn-large" id="topCleanAllBtn">
                    🗑️ Process All
                </button>
                <button class="btn btn-success btn-large" id="topDownloadAllBtn">
                    ⬇️ Download All as ZIP
                </button>
            </div>
        </div>

        <div class="upload-section" id="uploadSection">
            <div class="upload-icon">📁</div>
            <h3>Upload Your Media Files</h3>
            <p style="margin: 10px 0; color: #666;">
                Supports: Images (JPG, PNG, WebP, GIF) & Videos (MP4, WebM, AVI, MOV, MKV)
            </p>
            
            <div class="upload-buttons">
                <input type="file" id="fileInput" accept="image/*,video/*" multiple>
                <label for="fileInput" class="upload-btn">📄 Select Files</label>
                
                <input type="file" id="folderInput" webkitdirectory directory multiple>
                <label for="folderInput" class="upload-btn upload-btn-secondary">📂 Select Folder</label>
            </div>
        </div>

        <div id="mainContent" class="hidden">
            <div class="stats-bar">
                <div class="stat-card">
                    <div class="stat-value" id="totalImages">0</div>
                    <div class="stat-label">Images</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="totalVideos">0</div>
                    <div class="stat-label">Videos</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="cleanedMedia">0</div>
                    <div class="stat-label">Processed</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="totalSize">0 MB</div>
                    <div class="stat-label">Total Size</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="savedSize">0 KB</div>
                    <div class="stat-label">Size Saved</div>
                </div>
            </div>

            <div class="control-panel">
                <div class="control-tabs">
                    <button class="tab-btn active" data-tab="metadata">📝 Metadata Settings</button>
                    <button class="tab-btn" data-tab="image">🖼️ Image Processing</button>
                    <button class="tab-btn" data-tab="video">🎬 Video Processing</button>
                    <button class="tab-btn" data-tab="export">💾 Export Options</button>
                    <button class="tab-btn" data-tab="batch">⚙️ Batch Actions</button>
                </div>

                <!-- Metadata Settings Tab -->
                <div id="metadataTab" class="tab-content active">
                    <div class="settings-grid">
                        <div class="input-group">
                            <label for="authorInput">👤 Author</label>
                            <input type="text" id="authorInput" placeholder="Enter author name">
                        </div>
                        <div class="input-group">
                            <label for="copyrightInput">© Copyright</label>
                            <input type="text" id="copyrightInput" placeholder="© 2024 Your Name">
                        </div>
                        <div class="input-group">
                            <label for="titleInput">📌 Title</label>
                            <input type="text" id="titleInput" placeholder="Enter media title">
                        </div>
                        <div class="input-group">
                            <label for="keywordsInput">🏷️ Keywords/Tags</label>
                            <input type="text" id="keywordsInput" placeholder="nature, video, photo">
                        </div>
                        <div class="input-group">
                            <label for="descriptionInput">📄 Description</label>
                            <textarea id="descriptionInput" placeholder="Enter media description"></textarea>
                        </div>
                        <div class="input-group">
                            <label for="creditInput">💳 Credit/Source</label>
                            <input type="text" id="creditInput" placeholder="Media credit">
                        </div>
                    </div>
                    
                    <div class="info-box">
                        <strong>ℹ️ Metadata Options:</strong> Leave all fields empty for complete metadata wipe. 
                        Fill in only the fields you want to keep. All other metadata will be removed. 
                        Works for both images and videos!
                    </div>
                </div>

                <!-- Image Processing Tab -->
                <div id="imageTab" class="tab-content">
                    <div class="settings-grid">
                        <div class="input-group">
                            <label>📐 Resize Images</label>
                            <div class="checkbox-group">
                                <input type="checkbox" id="resizeEnabled">
                                <label for="resizeEnabled">Enable Resizing</label>
                            </div>
                            <select id="resizeMode" disabled>
                                <option value="percent">Percentage</option>
                                <option value="width">Fixed Width</option>
                                <option value="height">Fixed Height</option>
                                <option value="max">Max Dimension</option>
                            </select>
                            <input type="number" id="resizeValue" placeholder="Value" disabled>
                        </div>

                        <div class="input-group">
                            <label>🎨 Image Quality</label>
                            <div class="range-group">
                                <input type="range" id="qualitySlider" min="1" max="100" value="95">
                                <span class="range-value" id="qualityValue">95%</span>
                            </div>
                        </div>

                        <div class="input-group">
                            <label>🔄 Rotation</label>
                            <select id="rotationSelect">
                                <option value="0">No Rotation</option>
                                <option value="90">90° Clockwise</option>
                                <option value="180">180°</option>
                                <option value="270">270° Clockwise</option>
                            </select>
                        </div>

                        <div class="input-group">
                            <label>✨ Filters</label>
                            <select id="filterSelect">
                                <option value="none">None</option>
                                <option value="grayscale">Grayscale</option>
                                <option value="sepia">Sepia</option>
                                <option value="invert">Invert</option>
                                <option value="brightness">Increase Brightness</option>
                                <option value="contrast">Increase Contrast</option>
                            </select>
                        </div>

                        <div class="input-group">
                            <label>📦 Image Output Format</label>
                            <select id="imageFormat">
                                <option value="png">PNG (Lossless)</option>
                                <option value="jpeg">JPEG (Compressed)</option>
                                <option value="webp">WebP (Modern)</option>
                                <option value="original">Keep Original</option>
                            </select>
                        </div>
                    </div>
                </div>

                <!-- Video Processing Tab -->
                <div id="videoTab" class="tab-content">
                    <div class="video-settings-section">
                        <h4>⚠️ Video Processing Notes</h4>
                        <p style="font-size: 13px; color: #856404; line-height: 1.6;">
                            • Browser-based video re-encoding has limitations<br>
                            • Large videos may take time to process<br>
                            • Output format depends on browser support<br>
                            • All metadata will be stripped during re-encoding
                        </p>
                    </div>

                    <div class="settings-grid">
                        <div class="input-group">
                            <label>🎥 Video Quality</label>
                            <div class="range-group">
                                <input type="range" id="videoQualitySlider" min="1" max="10" value="8">
                                <span class="range-value" id="videoQualityValue">High</span>
                            </div>
                            <small style="color: #666;">1=Low, 5=Medium, 8=High, 10=Maximum</small>
                        </div>

                        <div class="input-group">
                            <label>📦 Video Output Format</label>
                            <select id="videoFormat">
                                <option value="webm">WebM (VP8/VP9)</option>
                                <option value="mp4">MP4 (H.264) - if supported</option>
                                <option value="original">Keep Original Format</option>
                            </select>
                        </div>

                        <div class="input-group">
                            <label>🎬 Video Processing Options</label>
                            <div class="checkbox-group">
                                <input type="checkbox" id="videoStripAudio">
                                <label for="videoStripAudio">Strip Audio Track</label>
                            </div>
                            <div class="checkbox-group">
                                <input type="checkbox" id="videoTrimEnabled">
                                <label for="videoTrimEnabled">Enable Trim (Start/End)</label>
                            </div>
                        </div>

                        <div class="input-group">
                            <label>⏱️ Bitrate (Mbps)</label>
                            <select id="videoBitrate">
                                <option value="1000000">1 Mbps (Low)</option>
                                <option value="2500000" selected>2.5 Mbps (Medium)</option>
                                <option value="5000000">5 Mbps (High)</option>
                                <option value="10000000">10 Mbps (Very High)</option>
                                <option value="auto">Auto (Browser Default)</option>
                            </select>
                        </div>

                        <div class="input-group">
                            <label>📐 Video Resolution</label>
                            <select id="videoResolution">
                                <option value="original">Keep Original</option>
                                <option value="480">480p</option>
                                <option value="720">720p (HD)</option>
                                <option value="1080">1080p (Full HD)</option>
                            </select>
                        </div>
                    </div>

                    <div class="info-box">
                        <strong>💡 Video Tips:</strong><br>
                        • Processing videos strips ALL metadata including GPS, camera info, and timestamps<br>
                        • Re-encoding may reduce file size significantly<br>
                        • For best compatibility, use WebM format<br>
                        • Processing time varies based on video length and quality
                    </div>
                </div>

                <!-- Export Options Tab -->
                <div id="exportTab" class="tab-content">
                    <div class="settings-grid">
                        <div class="input-group">
                            <label>📝 Filename Pattern</label>
                            <input type="text" id="filenamePattern" placeholder="e.g., clean_{original}_{date}">
                            <small style="color: #666; display: block; margin-top: 5px;">
                                Use: {original}, {author}, {date}, {index}, {type}
                            </small>
                        </div>

                        <div class="input-group">
                            <label>🗂️ Folder Structure in ZIP</label>
                            <select id="folderStructure">
                                <option value="flat">Single Folder</option>
                                <option value="bytype">Organize by Type (Images/Videos)</option>
                                <option value="original">Keep Original Structure</option>
                                <option value="bydate">Organize by Date</option>
                            </select>
                        </div>

                        <div class="input-group">
                            <label>📋 Export Options</label>
                            <div class="checkbox-group">
                                <input type="checkbox" id="exportMetadataFile" checked>
                                <label for="exportMetadataFile">Include metadata report (CSV)</label>
                            </div>
                            <div class="checkbox-group">
                                <input type="checkbox" id="exportReadme" checked>
                                <label for="exportReadme">Include README file</label>
                            </div>
                            <div class="checkbox-group">
                                <input type="checkbox" id="separateByType" checked>
                                <label for="separateByType">Separate images and videos in ZIP</label>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Batch Actions Tab -->
                <div id="batchTab" class="tab-content">
                    <div class="bulk-actions">
                        <button class="btn btn-danger" id="cleanAllBtn">
                            🗑️ Process All Media
                        </button>
                        <button class="btn btn-success" id="downloadAllBtn">
                            ⬇️ Download All (ZIP)
                        </button>
                        <button class="btn btn-primary" id="processImagesOnlyBtn">
                            🖼️ Process Images Only
                        </button>
                        <button class="btn btn-primary" id="processVideosOnlyBtn">
                            🎬 Process Videos Only
                        </button>
                        <button class="btn btn-warning" id="resetAllBtn">
                            🔄 Reset All
                        </button>
                        <button class="btn btn-info" id="selectAllBtn">
                            ✓ Select All
                        </button>
                        <button class="btn btn-info" id="deselectAllBtn">
                            ✗ Deselect All
                        </button>
                    </div>
                    
                    <div class="progress-bar" id="progressBar" style="display: none;">
                        <div class="progress-fill" id="progressFill" style="width: 0%"></div>
                    </div>

                    <div class="info-box" style="margin-top: 20px;">
                        <strong>💡 Batch Processing Tips:</strong><br>
                        • "Process All" handles both images and videos<br>
                        • Use type-specific buttons to process only images or videos<br>
                        • Video processing takes longer - be patient!<br>
                        • All metadata is completely removed during processing<br>
                        • Download creates organized ZIP with all processed files
                    </div>
                </div>
            </div>

            <div id="mediaGrid" class="media-grid"></div>

            <div id="emptyState" class="empty-state hidden">
                <div class="empty-state-icon">🎬</div>
                <h3>No media files loaded</h3>
                <p>Upload images or videos to get started</p>
            </div>
        </div>
    </div>

    <!-- Metadata Viewer Modal -->
    <div id="metadataModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>📋 Detailed Metadata</h2>
                <button class="close-modal" onclick="closeModal()">&times;</button>
            </div>
            <div id="modalMetadataContent"></div>
        </div>
    </div>

    <!-- JSZip Library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>

    <script>
        // State management
        let mediaFiles = [];
        let mediaIdCounter = 0;

        // DOM elements
        const fileInput = document.getElementById('fileInput');
        const folderInput = document.getElementById('folderInput');
        const uploadSection = document.getElementById('uploadSection');
        const mainContent = document.getElementById('mainContent');
        const topActions = document.getElementById('topActions');
        const mediaGrid = document.getElementById('mediaGrid');
        const emptyState = document.getElementById('emptyState');
        const alertBox = document.getElementById('alert');

        // Stats elements
        const totalImagesEl = document.getElementById('totalImages');
        const totalVideosEl = document.getElementById('totalVideos');
        const cleanedMediaEl = document.getElementById('cleanedMedia');
        const totalSizeEl = document.getElementById('totalSize');
        const savedSizeEl = document.getElementById('savedSize');

        // Top stats
        const topTotalMediaEl = document.getElementById('topTotalMedia');
        const topImageCountEl = document.getElementById('topImageCount');
        const topVideoCountEl = document.getElementById('topVideoCount');
        const topCleanedMediaEl = document.getElementById('topCleanedMedia');
        const topTotalSizeEl = document.getElementById('topTotalSize');

        // Control elements
        const authorInput = document.getElementById('authorInput');
        const copyrightInput = document.getElementById('copyrightInput');
        const titleInput = document.getElementById('titleInput');
        const keywordsInput = document.getElementById('keywordsInput');
        const descriptionInput = document.getElementById('descriptionInput');
        const creditInput = document.getElementById('creditInput');
        
        // Image settings
        const qualitySlider = document.getElementById('qualitySlider');
        const qualityValue = document.getElementById('qualityValue');
        const resizeEnabled = document.getElementById('resizeEnabled');
        const resizeMode = document.getElementById('resizeMode');
        const resizeValue = document.getElementById('resizeValue');
        const rotationSelect = document.getElementById('rotationSelect');
        const filterSelect = document.getElementById('filterSelect');
        const imageFormat = document.getElementById('imageFormat');

        // Video settings
        const videoQualitySlider = document.getElementById('videoQualitySlider');
        const videoQualityValue = document.getElementById('videoQualityValue');
        const videoFormat = document.getElementById('videoFormat');
        const videoStripAudio = document.getElementById('videoStripAudio');
        const videoBitrate = document.getElementById('videoBitrate');
        const videoResolution = document.getElementById('videoResolution');

        // Button elements
        const cleanAllBtn = document.getElementById('cleanAllBtn');
        const downloadAllBtn = document.getElementById('downloadAllBtn');
        const topCleanAllBtn = document.getElementById('topCleanAllBtn');
        const topDownloadAllBtn = document.getElementById('topDownloadAllBtn');
        const processImagesOnlyBtn = document.getElementById('processImagesOnlyBtn');
        const processVideosOnlyBtn = document.getElementById('processVideosOnlyBtn');
        const resetAllBtn = document.getElementById('resetAllBtn');
        const selectAllBtn = document.getElementById('selectAllBtn');
        const deselectAllBtn = document.getElementById('deselectAllBtn');

        const progressBar = document.getElementById('progressBar');
        const progressFill = document.getElementById('progressFill');

        // Event listeners
        fileInput.addEventListener('change', handleFileSelect);
        folderInput.addEventListener('change', handleFileSelect);
        uploadSection.addEventListener('dragover', handleDragOver);
        uploadSection.addEventListener('dragleave', handleDragLeave);
        uploadSection.addEventListener('drop', handleDrop);
        
        cleanAllBtn.addEventListener('click', () => processAllMedia());
        downloadAllBtn.addEventListener('click', downloadAllMedia);
        topCleanAllBtn.addEventListener('click', () => processAllMedia());
        topDownloadAllBtn.addEventListener('click', downloadAllMedia);
        processImagesOnlyBtn.addEventListener('click', () => processAllMedia('image'));
        processVideosOnlyBtn.addEventListener('click', () => processAllMedia('video'));
        resetAllBtn.addEventListener('click', resetAllMedia);
        selectAllBtn.addEventListener('click', selectAll);
        deselectAllBtn.addEventListener('click', deselectAll);

        qualitySlider.addEventListener('input', (e) => {
            qualityValue.textContent = e.target.value + '%';
        });

        videoQualitySlider.addEventListener('input', (e) => {
            const qualities = ['Very Low', 'Low', 'Low', 'Medium', 'Medium', 'Good', 'Good', 'High', 'High', 'Very High', 'Maximum'];
            videoQualityValue.textContent = qualities[parseInt(e.target.value) - 1];
        });

        resizeEnabled.addEventListener('change', (e) => {
            resizeMode.disabled = !e.target.checked;
            resizeValue.disabled = !e.target.checked;
        });

        // Tab switching
        document.querySelectorAll('.tab-btn').forEach(btn => {
            btn.addEventListener('click', function() {
                const tabName = this.dataset.tab;
                
                document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
                document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
                
                this.classList.add('active');
                document.getElementById(tabName + 'Tab').classList.add('active');
            });
        });

        function isVideoFile(file) {
            return file.type.startsWith('video/');
        }

        function isImageFile(file) {
            return file.type.startsWith('image/');
        }

        function handleFileSelect(e) {
            const files = Array.from(e.target.files).filter(file => 
                isImageFile(file) || isVideoFile(file)
            );
            
            if (files.length > 0) {
                addMediaFiles(files);
            } else {
                showAlert('No valid image or video files found', 'warning');
            }
        }

        function handleDragOver(e) {
            e.preventDefault();
            uploadSection.classList.add('dragover');
        }

        function handleDragLeave(e) {
            e.preventDefault();
            uploadSection.classList.remove('dragover');
        }

        function handleDrop(e) {
            e.preventDefault();
            uploadSection.classList.remove('dragover');
            
            const items = Array.from(e.dataTransfer.items);
            const files = [];

            const promises = items.map(item => {
                return new Promise((resolve) => {
                    if (item.kind === 'file') {
                        const entry = item.webkitGetAsEntry();
                        if (entry) {
                            if (entry.isFile) {
                                entry.file(file => {
                                    if (isImageFile(file) || isVideoFile(file)) {
                                        files.push(file);
                                    }
                                    resolve();
                                });
                            } else if (entry.isDirectory) {
                                readDirectory(entry, files).then(resolve);
                            }
                        } else {
                            const file = item.getAsFile();
                            if (file && (isImageFile(file) || isVideoFile(file))) {
                                files.push(file);
                            }
                            resolve();
                        }
                    } else {
                        resolve();
                    }
                });
            });

            Promise.all(promises).then(() => {
                if (files.length > 0) {
                    addMediaFiles(files);
                } else {
                    showAlert('No valid media files found', 'warning');
                }
            });
        }

        function readDirectory(directory, files) {
            return new Promise((resolve) => {
                const reader = directory.createReader();
                const readEntries = () => {
                    reader.readEntries(entries => {
                        if (entries.length === 0) {
                            resolve();
                            return;
                        }

                        const promises = entries.map(entry => {
                            return new Promise((resolveEntry) => {
                                if (entry.isFile) {
                                    entry.file(file => {
                                        if (isImageFile(file) || isVideoFile(file)) {
                                            files.push(file);
                                        }
                                        resolveEntry();
                                    });
                                } else if (entry.isDirectory) {
                                    readDirectory(entry, files).then(resolveEntry);
                                }
                            });
                        });

                        Promise.all(promises).then(readEntries);
                    });
                };
                readEntries();
            });
        }

        function addMediaFiles(files) {
            const imageCount = files.filter(isImageFile).length;
            const videoCount = files.filter(isVideoFile).length;

            files.forEach(file => {
                const id = mediaIdCounter++;
                const mediaType = isVideoFile(file) ? 'video' : 'image';
                const reader = new FileReader();
                
                reader.onload = function(e) {
                    const mediaData = {
                        id: id,
                        file: file,
                        name: file.name,
                        size: file.size,
                        type: file.type,
                        mediaType: mediaType,
                        originalDataUrl: e.target.result,
                        cleanedDataUrl: null,
                        cleanedBlob: null,
                        status: 'original',
                        metadata: {},
                        selected: true,
                        settings: getDefaultSettings(mediaType)
                    };

                    mediaFiles.push(mediaData);
                    extractMetadata(mediaData).then(() => {
                        renderMedia(mediaData);
                        updateStats();
                    });
                    
                    mainContent.classList.remove('hidden');
                    topActions.classList.add('show');
                    emptyState.classList.add('hidden');
                };
                
                reader.readAsDataURL(file);
            });

            showAlert(
                `✅ ${files.length} file(s) loaded! (${imageCount} images, ${videoCount} videos)`, 
                'success'
            );
        }

        function getDefaultSettings(mediaType) {
            return {
                author: '',
                copyright: '',
                title: '',
                keywords: '',
                description: '',
                credit: '',
                quality: 95,
                resize: false,
                resizeMode: 'percent',
                resizeValue: 100,
                rotation: 0,
                filter: 'none',
                format: mediaType === 'video' ? 'webm' : 'png',
                videoQuality: 8,
                videoBitrate: 2500000,
                videoResolution: 'original',
                stripAudio: false
            };
        }

        function extractMetadata(mediaData) {
            return new Promise((resolve) => {
                mediaData.metadata = {
                    'File Name': mediaData.name,
                    'File Size': formatBytes(mediaData.size),
                    'File Type': mediaData.type,
                    'Media Type': mediaData.mediaType.toUpperCase()
                };

                if (mediaData.mediaType === 'video') {
                    const video = document.createElement('video');
                    video.preload = 'metadata';
                    
                    video.onloadedmetadata = function() {
                        mediaData.metadata['Duration'] = formatDuration(video.duration);
                        mediaData.metadata['Dimensions'] = `${video.videoWidth} × ${video.videoHeight}`;
                        mediaData.metadata['Aspect Ratio'] = (video.videoWidth / video.videoHeight).toFixed(3);
                        mediaData.width = video.videoWidth;
                        mediaData.height = video.videoHeight;
                        mediaData.duration = video.duration;
                        resolve();
                    };
                    
                    video.onerror = function() {
                        mediaData.metadata['Error'] = 'Could not load video metadata';
                        resolve();
                    };
                    
                    video.src = mediaData.originalDataUrl;
                } else {
                    // Image metadata extraction
                    const reader = new FileReader();
                    reader.onload = function(e) {
                        const arrayBuffer = e.target.result;
                        const view = new DataView(arrayBuffer);
                        
                        // Check for JPEG
                        if (view.getUint16(0, false) === 0xFFD8) {
                            parseJPEGMetadata(view, mediaData.metadata);
                        } 
                        // Check for PNG
                        else if (view.getUint32(0, false) === 0x89504E47) {
                            parsePNGMetadata(view, mediaData.metadata);
                        }

                        const img = new Image();
                        img.onload = function() {
                            mediaData.metadata['Dimensions'] = `${img.width} × ${img.height}`;
                            mediaData.metadata['Aspect Ratio'] = (img.width / img.height).toFixed(3);
                            mediaData.width = img.width;
                            mediaData.height = img.height;
                            resolve();
                        };
                        img.src = mediaData.originalDataUrl;
                    };
                    reader.readAsArrayBuffer(mediaData.file);
                }
            });
        }

        function parseJPEGMetadata(view, metadata) {
            let offset = 2;
            while (offset < view.byteLength - 4) {
                const marker = view.getUint16(offset, false);
                if (marker < 0xFF00) break;
                const length = view.getUint16(offset + 2, false);
                
                if (marker === 0xFFE0) metadata['JFIF'] = 'Present';
                if (marker === 0xFFE1) metadata['EXIF Data'] = `Present (${formatBytes(length)})`;
                if (marker === 0xFFE2) metadata['ICC Profile'] = 'Present';
                if (marker === 0xFFED) metadata['Photoshop Data'] = 'Present';
                if (marker === 0xFFFE) metadata['Comment'] = 'Present';
                
                offset += 2 + length;
            }
        }

        function parsePNGMetadata(view, metadata) {
            let offset = 8;
            while (offset < view.byteLength - 8) {
                const length = view.getUint32(offset, false);
                const type = String.fromCharCode(
                    view.getUint8(offset + 4),
                    view.getUint8(offset + 5),
                    view.getUint8(offset + 6),
                    view.getUint8(offset + 7)
                );
                
                if (type === 'tEXt') metadata['PNG Text'] = 'Present';
                if (type === 'iTXt') metadata['PNG International Text'] = 'Present';
                if (type === 'pHYs') metadata['Physical Dimensions'] = 'Present';
                if (type === 'tIME') metadata['Modification Time'] = 'Present';
                if (type === 'eXIf') metadata['EXIF Data'] = 'Present';
                if (type === 'IEND') break;
                
                offset += 12 + length;
            }
        }

        function renderMedia(mediaData) {
            const card = document.createElement('div');
            card.className = 'media-card';
            card.id = `media-${mediaData.id}`;

            const metadataCount = Object.keys(mediaData.metadata).length;
            const metadataHtml = Object.entries(mediaData.metadata).slice(0, 3).map(([key, value]) => `
                <div class="metadata-item-small">
                    <span class="metadata-key-small">${key}</span>
                    <span class="metadata-value-small">${value}</span>
                </div>
            `).join('');

            const previewHtml = mediaData.mediaType === 'video' 
                ? `<video class="media-card-preview" src="${mediaData.originalDataUrl}" controls></video>`
                : `<img class="media-card-preview" src="${mediaData.originalDataUrl}" alt="${mediaData.name}">`;

            const badgeClass = mediaData.mediaType === 'video' ? 'badge-video' : 'badge-image';
            const badgeIcon = mediaData.mediaType === 'video' ? '🎬' : '🖼️';

            card.innerHTML = `
                ${previewHtml}
                <div class="media-card-body">
                    <div class="checkbox-group" style="margin-bottom: 10px;">
                        <input type="checkbox" id="select-${mediaData.id}" ${mediaData.selected ? 'checked' : ''} 
                               onchange="toggleMediaSelection(${mediaData.id})">
                        <label for="select-${mediaData.id}" class="media-card-title" title="${mediaData.name}">
                            ${mediaData.name}
                        </label>
                        <span class="media-type-badge ${badgeClass}">${badgeIcon} ${mediaData.mediaType}</span>
                    </div>
                    <div class="media-card-info">
                        ${formatBytes(mediaData.size)} • ${mediaData.type.split('/')[1].toUpperCase()}
                        ${mediaData.duration ? ` • ${formatDuration(mediaData.duration)}` : ''}
                    </div>
                    <div class="media-card-info">
                        ${mediaData.width} × ${mediaData.height} px • ${metadataCount} metadata fields
                    </div>
                    <span class="media-card-status status-${mediaData.status}" id="status-${mediaData.id}">
                        ${mediaData.status === 'original' ? '📋 Original' : '✓ Processed'}
                    </span>
                    <div class="metadata-preview">
                        ${metadataHtml}
                    </div>
                    <div class="media-card-actions">
                        <button class="btn btn-danger btn-small" onclick="processSingleMedia(${mediaData.id})">
                            🗑️ Process
                        </button>
                        <button class="btn btn-info btn-small" onclick="viewMetadata(${mediaData.id})">
                            📋 Metadata
                        </button>
                        <button class="btn btn-success btn-small" onclick="downloadSingleMedia(${mediaData.id})">
                            ⬇️ Download
                        </button>
                    </div>
                </div>
            `;

            mediaGrid.appendChild(card);
        }

        function toggleMediaSelection(id) {
            const mediaData = mediaFiles.find(m => m.id === id);
            if (mediaData) {
                mediaData.selected = !mediaData.selected;
            }
        }

        function selectAll() {
            mediaFiles.forEach(m => {
                m.selected = true;
                const checkbox = document.getElementById(`select-${m.id}`);
                if (checkbox) checkbox.checked = true;
            });
            showAlert('✓ All files selected', 'info');
        }

        function deselectAll() {
            mediaFiles.forEach(m => {
                m.selected = false;
                const checkbox = document.getElementById(`select-${m.id}`);
                if (checkbox) checkbox.checked = false;
            });
            showAlert('✗ All files deselected', 'info');
        }

        function updateMediaCard(mediaData) {
            const statusEl = document.getElementById(`status-${mediaData.id}`);
            if (statusEl) {
                statusEl.className = `media-card-status status-${mediaData.status}`;
                statusEl.textContent = mediaData.status === 'cleaned' ? '✓ Processed' : 
                                     mediaData.status === 'processing' ? '⏳ Processing...' : '📋 Original';
            }
        }

        async function processSingleMedia(id) {
            const mediaData = mediaFiles.find(m => m.id === id);
            if (!mediaData) return;

            mediaData.status = 'processing';
            updateMediaCard(mediaData);

            const settings = getCurrentSettings(mediaData.mediaType);
            
            try {
                if (mediaData.mediaType === 'video') {
                    await processVideo(mediaData, settings);
                } else {
                    await processImage(mediaData, settings);
                }
                
                mediaData.status = 'cleaned';
                updateMediaCard(mediaData);
                updateStats();
                
                showAlert(`✅ ${mediaData.mediaType === 'video' ? 'Video' : 'Image'} "${mediaData.name}" processed successfully!`, 'success');
            } catch (error) {
                mediaData.status = 'original';
                updateMediaCard(mediaData);
                showAlert(`❌ Error processing "${mediaData.name}": ${error.message}`, 'warning');
            }
        }

        function getCurrentSettings(mediaType) {
            return {
                author: authorInput.value.trim(),
                copyright: copyrightInput.value.trim(),
                title: titleInput.value.trim(),
                keywords: keywordsInput.value.trim(),
                description: descriptionInput.value.trim(),
                credit: creditInput.value.trim(),
                quality: parseInt(qualitySlider.value),
                resize: resizeEnabled.checked,
                resizeMode: resizeMode.value,
                resizeValue: parseInt(resizeValue.value) || 100,
                rotation: parseInt(rotationSelect.value),
                filter: filterSelect.value,
                format: mediaType === 'video' 
                    ? (videoFormat.value === 'original' ? 'webm' : videoFormat.value)
                    : (imageFormat.value === 'original' ? 'png' : imageFormat.value),
                videoQuality: parseInt(videoQualitySlider.value),
                videoBitrate: videoBitrate.value === 'auto' ? undefined : parseInt(videoBitrate.value),
                videoResolution: videoResolution.value,
                stripAudio: videoStripAudio.checked
            };
        }

        function processImage(mediaData, settings) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.onload = function() {
                    try {
                        let width = img.width;
                        let height = img.height;

                        // Apply resize
                        if (settings.resize) {
                            switch (settings.resizeMode) {
                                case 'percent':
                                    width = Math.round(width * settings.resizeValue / 100);
                                    height = Math.round(height * settings.resizeValue / 100);
                                    break;
                                case 'width':
                                    height = Math.round(height * settings.resizeValue / width);
                                    width = settings.resizeValue;
                                    break;
                                case 'height':
                                    width = Math.round(width * settings.resizeValue / height);
                                    height = settings.resizeValue;
                                    break;
                                case 'max':
                                    const maxDim = Math.max(width, height);
                                    if (maxDim > settings.resizeValue) {
                                        const scale = settings.resizeValue / maxDim;
                                        width = Math.round(width * scale);
                                        height = Math.round(height * scale);
                                    }
                                    break;
                            }
                        }

                        const canvas = document.createElement('canvas');
                        
                        // Handle rotation
                        if (settings.rotation === 90 || settings.rotation === 270) {
                            canvas.width = height;
                            canvas.height = width;
                        } else {
                            canvas.width = width;
                            canvas.height = height;
                        }

                        const ctx = canvas.getContext('2d');
                        
                        // Apply rotation
                        if (settings.rotation) {
                            ctx.translate(canvas.width / 2, canvas.height / 2);
                            ctx.rotate((settings.rotation * Math.PI) / 180);
                            ctx.translate(-width / 2, -height / 2);
                        }

                        // Draw image
                        ctx.drawImage(img, 0, 0, width, height);

                        // Apply filters
                        if (settings.filter !== 'none') {
                            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                            const data = imageData.data;

                            switch (settings.filter) {
                                case 'grayscale':
                                    for (let i = 0; i < data.length; i += 4) {
                                        const avg = (data[i] + data[i + 1] + data[i + 2]) / 3;
                                        data[i] = data[i + 1] = data[i + 2] = avg;
                                    }
                                    break;
                                case 'sepia':
                                    for (let i = 0; i < data.length; i += 4) {
                                        const r = data[i], g = data[i + 1], b = data[i + 2];
                                        data[i] = Math.min(255, r * 0.393 + g * 0.769 + b * 0.189);
                                        data[i + 1] = Math.min(255, r * 0.349 + g * 0.686 + b * 0.168);
                                        data[i + 2] = Math.min(255, r * 0.272 + g * 0.534 + b * 0.131);
                                    }
                                    break;
                                case 'invert':
                                    for (let i = 0; i < data.length; i += 4) {
                                        data[i] = 255 - data[i];
                                        data[i + 1] = 255 - data[i + 1];
                                        data[i + 2] = 255 - data[i + 2];
                                    }
                                    break;
                                case 'brightness':
                                    for (let i = 0; i < data.length; i += 4) {
                                        data[i] = Math.min(255, data[i] * 1.2);
                                        data[i + 1] = Math.min(255, data[i + 1] * 1.2);
                                        data[i + 2] = Math.min(255, data[i + 2] * 1.2);
                                    }
                                    break;
                                case 'contrast':
                                    const factor = (259 * (128 + 255)) / (255 * (259 - 128));
                                    for (let i = 0; i < data.length; i += 4) {
                                        data[i] = Math.min(255, Math.max(0, factor * (data[i] - 128) + 128));
                                        data[i + 1] = Math.min(255, Math.max(0, factor * (data[i + 1] - 128) + 128));
                                        data[i + 2] = Math.min(255, Math.max(0, factor * (data[i + 2] - 128) + 128));
                                    }
                                    break;
                            }

                            ctx.putImageData(imageData, 0, 0);
                        }

                        // Save settings
                        mediaData.settings = settings;
                        updateMetadataFromSettings(mediaData, settings);

                        // Convert to blob
                        const mimeType = `image/${settings.format}`;
                        const quality = settings.quality / 100;

                        canvas.toBlob(function(blob) {
                            if (!blob) {
                                reject(new Error('Failed to create blob'));
                                return;
                            }
                            
                            const reader = new FileReader();
                            reader.onload = function(e) {
                                mediaData.cleanedDataUrl = e.target.result;
                                mediaData.cleanedBlob = blob;
                                resolve();
                            };
                            reader.readAsDataURL(blob);
                        }, mimeType, quality);
                    } catch (error) {
                        reject(error);
                    }
                };
                img.onerror = () => reject(new Error('Failed to load image'));
                img.src = mediaData.originalDataUrl;
            });
        }

        function processVideo(mediaData, settings) {
            return new Promise((resolve, reject) => {
                const video = document.createElement('video');
                video.src = mediaData.originalDataUrl;
                video.muted = true;
                
                video.onloadedmetadata = async function() {
                    try {
                        let width = video.videoWidth;
                        let height = video.videoHeight;

                        // Apply resolution scaling
                        if (settings.videoResolution !== 'original') {
                            const targetHeight = parseInt(settings.videoResolution);
                            const scale = targetHeight / height;
                            width = Math.round(width * scale);
                            height = targetHeight;
                        }

                        const canvas = document.createElement('canvas');
                        canvas.width = width;
                        canvas.height = height;
                        const ctx = canvas.getContext('2d');

                        // Create MediaRecorder
                        const stream = canvas.captureStream(30); // 30 FPS
                        
                        if (!settings.stripAudio && video.captureStream) {
                            try {
                                const videoStream = video.captureStream();
                                const audioTracks = videoStream.getAudioTracks();
                                if (audioTracks.length > 0) {
                                    audioTracks.forEach(track => stream.addTrack(track));
                                }
                            } catch (e) {
                                console.log('Could not capture audio:', e);
                            }
                        }

                        const mimeType = settings.format === 'mp4' 
                            ? 'video/mp4; codecs="avc1.42E01E, mp4a.40.2"'
                            : 'video/webm; codecs=vp9';

                        // Check if MIME type is supported
                        const finalMimeType = MediaRecorder.isTypeSupported(mimeType) 
                            ? mimeType 
                            : 'video/webm';

                        const options = {
                            mimeType: finalMimeType,
                            videoBitsPerSecond: settings.videoBitrate
                        };

                        const mediaRecorder = new MediaRecorder(stream, options);
                        const chunks = [];

                        mediaRecorder.ondataavailable = (e) => {
                            if (e.data.size > 0) {
                                chunks.push(e.data);
                            }
                        };

                        mediaRecorder.onstop = () => {
                            const blob = new Blob(chunks, { type: finalMimeType });
                            const reader = new FileReader();
                            reader.onload = function(e) {
                                mediaData.cleanedDataUrl = e.target.result;
                                mediaData.cleanedBlob = blob;
                                mediaData.settings = settings;
                                updateMetadataFromSettings(mediaData, settings);
                                resolve();
                            };
                            reader.readAsDataURL(blob);
                        };

                        mediaRecorder.onerror = (e) => {
                            reject(new Error('MediaRecorder error: ' + e.error));
                        };

                        // Start recording
                        mediaRecorder.start(100); // Capture data every 100ms

                        // Play video and draw frames
                        video.play();
                        
                        const drawFrame = () => {
                            if (!video.paused && !video.ended) {
                                ctx.drawImage(video, 0, 0, width, height);
                                requestAnimationFrame(drawFrame);
                            }
                        };

                        video.onplay = () => {
                            drawFrame();
                        };

                        video.onended = () => {
                            setTimeout(() => {
                                mediaRecorder.stop();
                                stream.getTracks().forEach(track => track.stop());
                            }, 500);
                        };

                        // Set timeout for long videos
                        setTimeout(() => {
                            if (mediaRecorder.state === 'recording') {
                                video.pause();
                                mediaRecorder.stop();
                                stream.getTracks().forEach(track => track.stop());
                            }
                        }, Math.min(video.duration * 1000 + 5000, 300000)); // Max 5 minutes

                    } catch (error) {
                        reject(error);
                    }
                };

                video.onerror = () => reject(new Error('Failed to load video'));
            });
        }

        function updateMetadataFromSettings(mediaData, settings) {
            if (settings.author) mediaData.metadata['Author'] = settings.author;
            if (settings.copyright) mediaData.metadata['Copyright'] = settings.copyright;
            if (settings.title) mediaData.metadata['Title'] = settings.title;
            if (settings.keywords) mediaData.metadata['Keywords'] = settings.keywords;
            if (settings.description) mediaData.metadata['Description'] = settings.description;
            if (settings.credit) mediaData.metadata['Credit'] = settings.credit;
        }

        async function processAllMedia(typeFilter = null) {
            let selectedMedia = mediaFiles.filter(m => m.selected);
            
            if (typeFilter) {
                selectedMedia = selectedMedia.filter(m => m.mediaType === typeFilter);
            }
            
            if (selectedMedia.length === 0) {
                showAlert(`⚠️ No ${typeFilter || 'media'} files selected.`, 'warning');
                return;
            }

            progressBar.style.display = 'block';
            cleanAllBtn.disabled = true;
            topCleanAllBtn.disabled = true;
            cleanAllBtn.innerHTML = '<span class="loading-spinner"></span> Processing...';
            topCleanAllBtn.innerHTML = '<span class="loading-spinner"></span> Processing...';

            let processed = 0;
            const total = selectedMedia.length;
            let errors = 0;

            for (const mediaData of selectedMedia) {
                mediaData.status = 'processing';
                updateMediaCard(mediaData);
                
                const settings = getCurrentSettings(mediaData.mediaType);
                
                try {
                    if (mediaData.mediaType === 'video') {
                        await processVideo(mediaData, settings);
                    } else {
                        await processImage(mediaData, settings);
                    }
                    
                    mediaData.status = 'cleaned';
                } catch (error) {
                    console.error('Processing error:', error);
                    mediaData.status = 'original';
                    errors++;
                }
                
                updateMediaCard(mediaData);
                
                processed++;
                const progress = (processed / total) * 100;
                progressFill.style.width = `${progress}%`;
                
                await new Promise(resolve => setTimeout(resolve, 100));
            }

            progressBar.style.display = 'none';
            progressFill.style.width = '0%';
            cleanAllBtn.disabled = false;
            topCleanAllBtn.disabled = false;
            cleanAllBtn.innerHTML = '🗑️ Process All Media';
            topCleanAllBtn.innerHTML = '🗑️ Process All';
            
            updateStats();
            
            const successCount = total - errors;
            if (errors > 0) {
                showAlert(`⚠️ Processed ${successCount}/${total} files. ${errors} failed.`, 'warning');
            } else {
                showAlert(`✅ All ${total} selected file(s) processed successfully!`, 'success');
            }
        }

        function resetAllMedia() {
            if (!confirm('Are you sure you want to reset all media to original state?')) {
                return;
            }

            mediaFiles.forEach(m => {
                m.status = 'original';
                m.cleanedDataUrl = null;
                m.cleanedBlob = null;
                updateMediaCard(m);
            });

            updateStats();
            showAlert('🔄 All media reset to original state', 'info');
        }

        function downloadSingleMedia(id) {
            const mediaData = mediaFiles.find(m => m.id === id);
            if (!mediaData) return;

            if (!mediaData.cleanedBlob) {
                showAlert('⚠️ Please process the media first!', 'warning');
                return;
            }

            const url = URL.createObjectURL(mediaData.cleanedBlob);
            const a = document.createElement('a');
            a.href = url;
            
            const fileName = generateFilename(mediaData);
            a.download = fileName;
            
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            showAlert(`⬇️ "${fileName}" downloaded!`, 'success');
        }

        function generateFilename(mediaData) {
            const pattern = document.getElementById('filenamePattern').value || 'clean_{original}';
            const baseName = mediaData.name.replace(/\.[^/.]+$/, "");
            const ext = mediaData.settings?.format || (mediaData.mediaType === 'video' ? 'webm' : 'png');
            const date = new Date().toISOString().split('T')[0];
            const index = mediaData.id;

            let filename = pattern
                .replace('{original}', baseName)
                .replace('{author}', mediaData.settings?.author || '')
                .replace('{date}', date)
                .replace('{index}', index)
                .replace('{type}', mediaData.mediaType);

            return `${filename}.${ext}`;
        }

        async function downloadAllMedia() {
            const processedMedia = mediaFiles.filter(m => m.cleanedBlob && m.selected);
            
            if (processedMedia.length === 0) {
                showAlert('⚠️ Please process at least one selected file first!', 'warning');
                return;
            }

            if (processedMedia.length === 1) {
                downloadSingleMedia(processedMedia[0].id);
                return;
            }

            downloadAllBtn.disabled = true;
            topDownloadAllBtn.disabled = true;
            downloadAllBtn.innerHTML = '<span class="loading-spinner"></span> Creating ZIP...';
            topDownloadAllBtn.innerHTML = '<span class="loading-spinner"></span> Creating ZIP...';
            
            const zip = new JSZip();
            const separateByType = document.getElementById('separateByType').checked;

            // Organize files
            processedMedia.forEach(mediaData => {
                const fileName = generateFilename(mediaData);
                
                if (separateByType) {
                    const folderName = mediaData.mediaType === 'video' ? 'videos' : 'images';
                    zip.folder(folderName).file(fileName, mediaData.cleanedBlob);
                } else {
                    zip.file(fileName, mediaData.cleanedBlob);
                }
            });

            // Add metadata CSV if enabled
            if (document.getElementById('exportMetadataFile').checked) {
                let csv = 'Filename,Type,Original Size,Processed Size,Dimensions,Duration,Author,Title\n';
                processedMedia.forEach(mediaData => {
                    const fileName = generateFilename(mediaData);
                    csv += `"${fileName}","${mediaData.mediaType}","${formatBytes(mediaData.size)}",` +
                           `"${formatBytes(mediaData.cleanedBlob.size)}","${mediaData.width}x${mediaData.height}",` +
                           `"${mediaData.duration ? formatDuration(mediaData.duration) : 'N/A'}",` +
                           `"${mediaData.settings?.author || ''}","${mediaData.settings?.title || ''}"\n`;
                });
                zip.file('metadata_report.csv', csv);
            }

            // Add README if enabled
            if (document.getElementById('exportReadme').checked) {
                const readme = generateReadme(processedMedia);
                zip.file('README.txt', readme);
            }

            zip.generateAsync({ type: 'blob' }).then(function(content) {
                const url = URL.createObjectURL(content);
                const a = document.createElement('a');
                a.href = url;
                a.download = `processed_media_${Date.now()}.zip`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                downloadAllBtn.disabled = false;
                topDownloadAllBtn.disabled = false;
                downloadAllBtn.innerHTML = '⬇️ Download All (ZIP)';
                topDownloadAllBtn.innerHTML = '⬇️ Download All as ZIP';
                
                const imageCount = processedMedia.filter(m => m.mediaType === 'image').length;
                const videoCount = processedMedia.filter(m => m.mediaType === 'video').length;
                
                showAlert(
                    `⬇️ ZIP downloaded! ${imageCount} images, ${videoCount} videos`, 
                    'success'
                );
            });
        }

        function generateReadme(mediaFiles) {
            const imageCount = mediaFiles.filter(m => m.mediaType === 'image').length;
            const videoCount = mediaFiles.filter(m => m.mediaType === 'video').length;
            const settings = mediaFiles[0]?.settings || {};
            
            return `Processed Media Files - Metadata Report
=========================================

Total files: ${mediaFiles.length}
Images: ${imageCount}
Videos: ${videoCount}
Processed on: ${new Date().toLocaleString()}

Settings Applied:
-----------------
${settings.author ? `Author: ${settings.author}` : 'Author: Not specified'}
${settings.copyright ? `Copyright: ${settings.copyright}` : ''}
${settings.title ? `Title: ${settings.title}` : ''}
${settings.keywords ? `Keywords: ${settings.keywords}` : ''}

Image Settings:
Quality: ${settings.quality}%
Format: ${settings.format}

Video Settings:
Quality Level: ${settings.videoQuality}/10
Bitrate: ${settings.videoBitrate ? (settings.videoBitrate / 1000000) + ' Mbps' : 'Auto'}
Resolution: ${settings.videoResolution}
Audio: ${settings.stripAudio ? 'Stripped' : 'Preserved (if possible)'}

Metadata Status:
----------------
ALL original metadata has been completely removed including:
- EXIF data (GPS, camera info, timestamps)
- File creation/modification dates
- Camera settings and device information
- Software/application metadata
- Embedded thumbnails
- Color profiles
- Comments and annotations

${settings.author || settings.copyright || settings.title ? 'New metadata fields added as specified above.' : 'Files are completely clean with zero metadata.'}

Files Included:
---------------
${mediaFiles.map((m, i) => `${i + 1}. ${generateFilename(m)} (${m.mediaType.toUpperCase()}, ${formatBytes(m.cleanedBlob.size)})`).join('\n')}

---
Generated by Universal Media Metadata Cleaner
Supports both images and videos with complete metadata removal
`;
        }

        function viewMetadata(id) {
            const mediaData = mediaFiles.find(m => m.id === id);
            if (!mediaData) return;

            const modal = document.getElementById('metadataModal');
            const content = document.getElementById('modalMetadataContent');

            let html = '<h3>Original Metadata</h3>';
            html += '<div class="metadata-display">';
            
            for (const [key, value] of Object.entries(mediaData.metadata)) {
                html += `
                    <div class="metadata-item">
                        <span class="metadata-key">${key}</span>
                        <span class="metadata-value">${value}</span>
                    </div>
                `;
            }
            
            html += '</div>';

            if (mediaData.cleanedBlob) {
                html += '<h3 style="margin-top: 20px;">Applied Settings</h3>';
                html += '<div class="metadata-display">';
                const settings = mediaData.settings;
                
                if (settings.author) html += `<div class="metadata-item"><span class="metadata-key">Author</span><span class="metadata-value">${settings.author}</span></div>`;
                if (settings.copyright) html += `<div class="metadata-item"><span class="metadata-key">Copyright</span><span class="metadata-value">${settings.copyright}</span></div>`;
                if (settings.title) html += `<div class="metadata-item"><span class="metadata-key">Title</span><span class="metadata-value">${settings.title}</span></div>`;
                
                html += `<div class="metadata-item"><span class="metadata-key">Processed Size</span><span class="metadata-value">${formatBytes(mediaData.cleanedBlob.size)}</span></div>`;
                html += `<div class="metadata-item"><span class="metadata-key">Format</span><span class="metadata-value">${settings.format.toUpperCase()}</span></div>`;
                
                html += '</div>';
            }

            content.innerHTML = html;
            modal.classList.add('show');
        }

        function closeModal() {
            document.getElementById('metadataModal').classList.remove('show');
        }

        function updateStats() {
            const images = mediaFiles.filter(m => m.mediaType === 'image');
            const videos = mediaFiles.filter(m => m.mediaType === 'video');
            const processed = mediaFiles.filter(m => m.status === 'cleaned');
            const totalBytes = mediaFiles.reduce((sum, m) => sum + m.size, 0);
            const savedBytes = mediaFiles.reduce((sum, m) => {
                if (m.cleanedBlob) {
                    return sum + (m.size - m.cleanedBlob.size);
                }
                return sum;
            }, 0);

            totalImagesEl.textContent = images.length;
            totalVideosEl.textContent = videos.length;
            cleanedMediaEl.textContent = processed.length;
            totalSizeEl.textContent = formatBytes(totalBytes);
            savedSizeEl.textContent = formatBytes(savedBytes);

            topTotalMediaEl.textContent = mediaFiles.length;
            topImageCountEl.textContent = images.length;
            topVideoCountEl.textContent = videos.length;
            topCleanedMediaEl.textContent = processed.length;
            topTotalSizeEl.textContent = formatBytes(totalBytes);
        }

        function showAlert(message, type) {
            alertBox.textContent = message;
            alertBox.className = `alert alert-${type} show`;
            
            setTimeout(() => {
                alertBox.classList.remove('show');
            }, 6000);
        }

        function formatBytes(bytes) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return Math.round(bytes / Math.pow(k, i) * 100) / 100 + ' ' + sizes[i];
        }

        function formatDuration(seconds) {
            const hrs = Math.floor(seconds / 3600);
            const mins = Math.floor((seconds % 3600) / 60);
            const secs = Math.floor(seconds % 60);
            
            if (hrs > 0) {
                return `${hrs}:${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
            }
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }

        // Close modal on outside click
        window.onclick = function(event) {
            if (event.target.classList.contains('modal')) {
                event.target.classList.remove('show');
            }
        }
    </script>
</body>
</html>
